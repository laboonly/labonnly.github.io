(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{494:function(a,s,t){"use strict";t.r(s);var e=t(4),n=Object(e.a)({},(function(){var a=this,s=a.$createElement,t=a._self._c||s;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"前端面试题整理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端面试题整理"}},[a._v("#")]),a._v(" 前端面试题整理")]),a._v(" "),t("h2",{attrs:{id:"seo"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#seo"}},[a._v("#")]),a._v(" SEO")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. 合理的设置title、description、keywords,\n2. 语义化的HTML代码\n3. 重要的html代码放在前面\n4. 重要内容不要用js输出，爬虫不会抓取js获取内容\n5. 少用iframe，爬虫不会抓取iframe里面的内容\n6. 非装饰性图片加alt属性\n7. 提高网站速度 \n")])])]),t("h2",{attrs:{id:"cdn"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#cdn"}},[a._v("#")]),a._v(" CDN")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("将图片跟视频放在CDN服务上面，实例七牛储存图片。\n")])])]),t("h2",{attrs:{id:"如何实现浏览器内多个标签页之间的通信"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何实现浏览器内多个标签页之间的通信"}},[a._v("#")]),a._v(" 如何实现浏览器内多个标签页之间的通信？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. iframe + contentWindow\n2. postMessage\nWindows.postMessage()方法项目目标窗口发送一个MessageEvent消息\n")])])]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v('otherWindow.postMessage(message, targetOrigin, [transfer])\n\nwindow.addEventListener("message", receiveMessage, false);\n\t\n')])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br")])]),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("4. SharedWorker(Web Worker API)\n5. localStorge(localStorge API)\n6. WebSocket\n")])])]),t("h2",{attrs:{id:"前端代码和资源的压缩与合并"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#前端代码和资源的压缩与合并"}},[a._v("#")]),a._v(" 前端代码和资源的压缩与合并")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. Gzip压缩：Web服务器开启Gzip压缩后，会在Response的header中增加了Content-Encoding:gzip\n2. js代码压缩\n去掉多余的空格和回车，替换长的变量名，简化一些代码的写法。\n3. 图片视频资源压缩\n")])])]),t("h2",{attrs:{id:"css-盒模型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#css-盒模型"}},[a._v("#")]),a._v(" CSS 盒模型")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("基本的：content的宽度 box-sizing: content-box\nIE: width 属性不是内容的宽度，而是内容、内边距和边框的宽度的总和。\nbox-sizing: boder-box\n")])])]),t("h2",{attrs:{id:"层叠上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#层叠上下文"}},[a._v("#")]),a._v(" 层叠上下文")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("z-index: \n")])])]),t("h2",{attrs:{id:"清除浮动"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#清除浮动"}},[a._v("#")]),a._v(" 清除浮动")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("增加伪元素clear: both\n创建父级BFC\n")])])]),t("h2",{attrs:{id:"居中布局"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#居中布局"}},[a._v("#")]),a._v(" 居中布局")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("块级元素\n行内元素\n")])])]),t("h2",{attrs:{id:"js的基本数据类型和引用数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js的基本数据类型和引用数据类型"}},[a._v("#")]),a._v(" JS的基本数据类型和引用数据类型")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("基本数据类型：undefined、null、boolean、number、string、symbol\n引用数据类型：object、array、function\n")])])]),t("h2",{attrs:{id:"图片实现自适应宽高"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图片实现自适应宽高"}},[a._v("#")]),a._v(" 图片实现自适应宽高")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("<img> 属性是会自动调整图片的宽高比，但是在布局家在当中图片高度会实现一个0到高度的变化 ，影响页面布局。<div>中使用padding 设置%值因为padding%的取值是基于宽度的\n")])])]),t("h2",{attrs:{id:"flex常见属性"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#flex常见属性"}},[a._v("#")]),a._v(" flex常见属性")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("flex-direction flex-wrap justify-content  align-items \n")])])]),t("h2",{attrs:{id:"bfc是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bfc是什么"}},[a._v("#")]),a._v(" BFC是什么")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。\t\n1. 属于同一个 BFC 的两个相邻 Box 垂直排列\n2. 属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠\n3. BFC 中子元素不会超出他的包含块\n4. BFC 的区域不会与 float 的元素区域重叠\n5. 计算 BFC 的高度时，浮动子元素也参与计算\n6. 文字层不会被浮动层覆盖，环绕于周围\n")])])]),t("h2",{attrs:{id:"什么是事件代理-事件委托"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是事件代理-事件委托"}},[a._v("#")]),a._v(" 什么是事件代理(事件委托)？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("减少dom交互次数，提高了性能，利用了事件冒泡解决。\n利用target属性(可以返回事件的目标节点，我们成为事件源)。\n适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。\n")])])]),t("h2",{attrs:{id:"项目里面的前端鉴权是怎么实现的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#项目里面的前端鉴权是怎么实现的"}},[a._v("#")]),a._v(" 项目里面的前端鉴权是怎么实现的？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. 1. HTTP Basic Authentication (HTTP基本认证)\n\t将认证信息储存在 Authentication 中 \n\n3. session-cookie\n将信息储存在session-cookie中\n\t带有状态 session 会在一次会话结束之后关掉\n\n5. Token 验证(包括JWT,SSO)\n \tJWT：讲Token放入Authorization，Authorization: Bearer <token>\n\t多平台 \n\n7. OAuth(开放授权)\n微信授权\n")])])]),t("h2",{attrs:{id:"防抖和函数节流"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#防抖和函数节流"}},[a._v("#")]),a._v(" 防抖和函数节流")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("防抖：指定时间间隔内只会执行一次任务\n节流：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。\n")])])]),t("h2",{attrs:{id:"js原型-构造函数-实例"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js原型-构造函数-实例"}},[a._v("#")]),a._v(" js原型_构造函数_实例")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("![](1460000018155881.jpg)\n[最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一） - 简书](https://www.jianshu.com/p/dee9f8b14771)\n")])])]),t("h2",{attrs:{id:"原型链"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[a._v("#")]),a._v(" 原型链：")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("**原型链是由原型对象组成**，每个对象都有__proto__属性，指向了创建该对象的构造函数的原型，__proto__将对象连接起来组成了原型链。是一个用来**实现继承和共享属性**的有限的对象链。\n属性查找机制\n属性修改机制\n")])])]),t("h2",{attrs:{id:"执行上下文"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#执行上下文"}},[a._v("#")]),a._v(" 执行上下文")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. 它包含三个部分:\n\t变量对象(VO)\n\t作用域链(词法作用域)\n\tthis指向\n2. 它的类型:\n\t 全局执行上下文\n\t 函数执行上下文\n \teval执行上下文\n3.  代码执行过程:\n 创建**全局上下文**(global EC)\n 全局执行上下文 (caller) 逐行**自上而下**执行。遇到函数时，**函数执行上下文**(callee) 被push到执行栈顶层\n 函数执行上下文被激活，成为 active EC, 开始执行函数中的代码，caller 被挂起\n 函数执行完后，callee 被pop移除出执行栈，控制权交还全局上下文 (caller)，继续执行\n")])])]),t("h2",{attrs:{id:"常用的es6语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#常用的es6语法"}},[a._v("#")]),a._v(" 常用的es6语法")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1.  let 块级作用域，不存在变量提升。\n2. 解构复制 \n3. promise\nPromise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一\t\t的 API，各种异步操作都可以用同样的方法进行处理。\n三个状态 。两个回调函数 两个函数参数。\n不要在then方法里面定义 Reject 状态的回调函数（即then的第二个参\t数），总是使用catch方法。\n\n4. Iterator\n遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。\n\n5. class\n\t\n6. Generator\n一种异步编程解决方案\n")])])]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("  function* helloWorldGenerator() {\n  yield 'hello';\n  yield 'world';\n  return 'ending';\n }\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])]),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("7. async 函数  \n\tGenerator 函数的语法糖。\n\n8. Set / Map \nSet 类似于数组但是值都是唯一的 WeakSet 值只能是对象\nMap “值-值”的对集合 WeakMap 只接受对象作为键名\n")])])]),t("h2",{attrs:{id:"代码的复用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代码的复用"}},[a._v("#")]),a._v(" 代码的复用")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("函数的封装\n继承\n复制\n混入\n借用\n")])])]),t("h2",{attrs:{id:"模块化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[a._v("#")]),a._v(" 模块化")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("分类：\n\tes6: import/exports\n\tcommonjs: require / module.exports / exports\n\tamd: require / defined\nrequire与import\n\trequire支持动态导入\n\trequire是同步导入，import属于异步导入\n\trepuire是值拷贝，import指向内存地址\n")])])]),t("h2",{attrs:{id:"图片懒加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#图片懒加载"}},[a._v("#")]),a._v(" 图片懒加载")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("将图片地址储存在，data-XXX中然后在JS里面判断图片在可视区域内在设置图片src\n")])])]),t("h2",{attrs:{id:"跨域"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#跨域"}},[a._v("#")]),a._v(" 跨域")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("JSONP\n\t利用<script>标签不受跨域的特点实现，缺点只能支持get请求\nCORS跨域资源共享\n\t后端设置， Access-Control-Allow-Origin，Access-Control-Allow-Credentials\npostMessage\n")])])]),t("h2",{attrs:{id:"http状态码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http状态码"}},[a._v("#")]),a._v(" http状态码")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("100 Continue 一般在发送post请求时  http header返回此信息表示确认\n200 OK 成功信息\n201 Created 请求成功并且创建了新的资源\n202 Accepted 服务器接受了请求但尚未处理\n301 Moved Permanently 请求网站已永久移动到了新的位置\n304 自从上次请求之后，网页未修改过\n403 禁止访问\n404 找不到如何与Url相匹配的资源\n500 常见服务器错误\n")])])]),t("h2",{attrs:{id:"http和https"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http和https"}},[a._v("#")]),a._v(" HTTP和HTTPS")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS\n默认HTTP的端口号为80，HTTPS的端口号为443\n    基本方法: GET, POST, PUT,DLETE\n    请求消息：![](2012072810301161.png)\n    响应消息\n        状态行\n        消息报头\n        空行\n        响应正文\nkeepalive:\n        Connection: Keep-Alive 避免重新建立连接\n")])])]),t("h2",{attrs:{id:"tcp三次握手"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#tcp三次握手"}},[a._v("#")]),a._v(" TCP三次握手")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("    所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。\n三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。在 socket 编程中，客户端执行connect()时。将触发三次握手。\n1.  第一次握手(SYN=1, seq=x):\n客户端发送一个 TCP 的 SYN 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X,保存在包头的序列号(Sequence Number)字段里。\n发送完毕后，客户端进入SYN_SEND状态。\n\n2. 第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1):\n服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即X+1。 发送完毕后，服务器端进入SYN_RCVD状态。\n\n3. 第三次握手(ACK=1，ACKnum=y+1)\n客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1\n发送完毕后，客户端进入ESTABLISHED状态，当服务器端接收到这个包时，也进入ESTABLISHED状态，TCP 握手结束。\n")])])]),t("h2",{attrs:{id:"http缓存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[a._v("#")]),a._v(" http缓存")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. 缓存控制\n http1.0 :\n\tPragma:   no-cache 不缓存\n\tExpires： GMT 缓存 设置缓存时间\n\nCache-Control： \n\tno-cache: 缓存\n\tno-store: 不被缓存\n            max-age：缓存时间\n\tpublic\n\tprivate\n\tmust-revalidate\n\n2.  缓存校验\nLast-Modified: GMT 加在实体首部  服务端设置  [If-Modified-Since](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-Modified-Since) \n\nETag： 服务器在第一次返回资源时会加上一个Etag，浏览器在再次请求此资源的时候设置 [If-None-Match](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/If-None-Match)会携带上这个Etag，服务器检查这个Etag，判断为没有修改之后，返回响应304，并且一个空的返回体\n\nVary： User-Agent 因用于不同设备之间的缓存判断\n")])])]),t("h2",{attrs:{id:"柯里化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#柯里化"}},[a._v("#")]),a._v(" 柯里化")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("函数分步传递参数，每次传递部分参数，并返回一个更具体的函数接收剩下的参数，这中间可嵌套多层这样的接收部分参数的函数，直至返回最后结果。\n")])])]),t("h2",{attrs:{id:"深浅拷贝"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#深浅拷贝"}},[a._v("#")]),a._v(" 深浅拷贝")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("基本数据类型跟应用数据类型。\n浅拷贝只是复制了对象的应用，\n深拷贝，json反序列化，递归复制\n[深浅拷贝原理](https://segmentfault.com/a/1190000008838101)\n")])])]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("function deepCopy (obj) {\n    var result;\n\n    //引用类型分数组和对象分别递归\n    if (Object.prototype.toString.call(obj) == '[object Array]') {\n      result = []\n      for (i = 0; i < obj.length; i++) {\n        result[i] = deepCopy(obj[i])\n      }\n    } else if (Object.prototype.toString.call(obj) == '[object Object]') {\n      result = {}\n      for (var attr in obj) {\n        result[attr] = deepCopy(obj[attr])\n      }\n    }\n    //值类型直接返回\n    else {\n      return obj\n    }\n    return result\n}\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br"),t("span",{staticClass:"line-number"},[a._v("12")]),t("br"),t("span",{staticClass:"line-number"},[a._v("13")]),t("br"),t("span",{staticClass:"line-number"},[a._v("14")]),t("br"),t("span",{staticClass:"line-number"},[a._v("15")]),t("br"),t("span",{staticClass:"line-number"},[a._v("16")]),t("br"),t("span",{staticClass:"line-number"},[a._v("17")]),t("br"),t("span",{staticClass:"line-number"},[a._v("18")]),t("br"),t("span",{staticClass:"line-number"},[a._v("19")]),t("br"),t("span",{staticClass:"line-number"},[a._v("20")]),t("br"),t("span",{staticClass:"line-number"},[a._v("21")]),t("br")])]),t("h2",{attrs:{id:"symbol"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#symbol"}},[a._v("#")]),a._v(" symbol")]),a._v(" "),t("h2",{attrs:{id:"一个完整的http事务是怎样一个过程"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一个完整的http事务是怎样一个过程"}},[a._v("#")]),a._v(" 一个完整的http事务是怎样一个过程？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("1. 域名解析\n2. 发起TCP三次握手\n3. 建立TCP请求之后发起http请求\n4. 服务器端响应http请求，浏览器得到html代码\n5. 浏览器解析html代码，并请求html代码中的资源\n6. 浏览器对页面进行渲染呈现给用户 \n")])])]),t("h2",{attrs:{id:"generator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[a._v("#")]),a._v(" Generator")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("...\n")])])]),t("h2",{attrs:{id:"async"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#async"}},[a._v("#")]),a._v(" async")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("...\n")])])]),t("h2",{attrs:{id:"axios"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#axios"}},[a._v("#")]),a._v(" axios")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("创建axios是咧`const service = axios.create` \n实例的方法：\n\t1. request\n\t2. get\n\t3. post\n\t4. delete\n\t5. head\n\t6. put \n\t\n请求配置 \n")])])]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\t{\n\t\turl: \n\t\tmethods:\n\t\tbaseurl:\n\t\ttransformrequest: //对data进行任意转换处理\n\t\ttimeout: \n\t\tresponseType: \n\t\t...\n\t}\t\t \n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br")])]),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("请求拦截器 `axios.interceptors.request.use`\n\n响应拦截器 `axios.interceptors.response.use`\n")])])]),t("h2",{attrs:{id:"重绘与回流-重排"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#重绘与回流-重排"}},[a._v("#")]),a._v(" 重绘与回流(重排)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("重绘： 样式不改变布局，只进行UI层面的重新像素绘制，开销较少\n回流(重排)： 元素的尺寸，结构改变或者出发某些属性(伪类)浏览器重新渲染\n总结：\n\t1. 避免频繁操作样式可汇总后统一修改\n\t2. 尽量少使用class进行样式修改\n\t3. 减少dom增删次数\n\t4. 使用变量存住 -> 获取DOM之后用变量储存\n")])])]),t("h2",{attrs:{id:"储存-请描述一下-cookies-sessionstorage-和-localstorage-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#储存-请描述一下-cookies-sessionstorage-和-localstorage-的区别"}},[a._v("#")]),a._v(" 储存 请描述一下 cookies，sessionStorage 和 localStorage 的区别？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("浏览器：\n\t cookie： 通常用于储存用户身份，登录状态，http中自动携带，体积上限为4k，可自行设置过期时间。储存量小，只能储存字符串，影响性能\n\n\tlocalStorage/ sessionStorage: 长时间储存，体积为4M，localStorage没有过期时间，sessionStorage，窗口关闭删除\n\n\tIndexDB：受同源策略的限制  \n\n服务器：\n\t分布式缓存redis\n\t数据库\n")])])]),t("h2",{attrs:{id:"web-worker"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#web-worker"}},[a._v("#")]),a._v(" Web Worker")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("多线程环境，可分配任务到worker中并行运行，两个线程可独立运行，互不干扰，可自带消息机制相互通信\n")])])]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\t// 创建 worker\n\t\tconst worker = new Worker('work.js');\n\n\t// 向主进程推送消息\n\tworker.postMessage('Hello World');\n\n\t// 监听主进程来的消息\n\tworker.onmessage = function (event) {\n  \tconsole.log('Received message ' + event.data);\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br")])]),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("限制：\n\t同源策略\n\t无法使用 document_windows_alert/confirm\n\t无法加载本地资源\n")])])]),t("h2",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[a._v("#")]),a._v(" 垃圾回收")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("考虑某个变量或对象在未来的程序运行中将不会被访问  向这些对象要求归还内存\n**引用计数**  **标记-清除**  \n")])])]),t("h2",{attrs:{id:"内存泄漏"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏"}},[a._v("#")]),a._v(" 内存泄漏")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("主要是因为程序不能释放那些不再使用的内存\n**循环引用**\n**无意的全局变量**\n**被遗忘的计时器和回调函数** setInterval  setTiemout\n")])])]),t("h2",{attrs:{id:"websocket"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#websocket"}},[a._v("#")]),a._v(" Websocket")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("websocket是一个持久化协议，基于http，服务端可以主动push\n数据格式比较轻量，性能开销小，通信高效。\n可以发送文本，也可以发送二进制数据。\n没有同源策略限制\n长轮询 ：客户端不断的向服务端发送请求\nlong poll  有消息时服务端向客户端发送请求\n")])])]),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("\tnew WebSocket(url)\n\tws.onerror = fn\n\n\tws.onclose = fn\n\n\tws.onopen = fn\n\n\tws.onmessage = fn\n\n\tws.send()\n\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br"),t("span",{staticClass:"line-number"},[a._v("6")]),t("br"),t("span",{staticClass:"line-number"},[a._v("7")]),t("br"),t("span",{staticClass:"line-number"},[a._v("8")]),t("br"),t("span",{staticClass:"line-number"},[a._v("9")]),t("br"),t("span",{staticClass:"line-number"},[a._v("10")]),t("br"),t("span",{staticClass:"line-number"},[a._v("11")]),t("br")])]),t("h2",{attrs:{id:"实现一个二叉树的优先遍历"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#实现一个二叉树的优先遍历"}},[a._v("#")]),a._v(" 实现一个二叉树的优先遍历")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("[js 中二叉树的深度遍历与广度遍历(递归实现与非递归实现) - 简书](https://www.jianshu.com/p/5e9ea25a1aae)\n")])])]),t("h2",{attrs:{id:"addeventlistener-第三个参数的作用是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#addeventlistener-第三个参数的作用是什么"}},[a._v("#")]),a._v(" addEventListener,第三个参数的作用是什么")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("可选。布尔值，指定事件是否在捕获或冒泡阶段执行。\n")])])]),t("h2",{attrs:{id:"js事件阶段-捕获-目标-冒泡-阻止冒泡有哪些方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js事件阶段-捕获-目标-冒泡-阻止冒泡有哪些方法"}},[a._v("#")]),a._v(" js事件阶段（捕获>目标>冒泡），阻止冒泡有哪些方法？")]),a._v(" "),t("h2",{attrs:{id:"那么-apply、call、bind-三者相比较-之间又有什么异同呢"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#那么-apply、call、bind-三者相比较-之间又有什么异同呢"}},[a._v("#")]),a._v(" 那么 apply、call、bind 三者相比较，之间又有什么异同呢？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("[JS中的call、apply、bind方法详解 - 风雨后见彩虹 - 博客园](https://www.cnblogs.com/moqiutao/p/7371988.html)\n区别是，当你希望改变上下文环境之后并非立即执行，而是回调执行的时候，使用 bind() 方法。而 apply/call 则会立即执行函数。\n")])])]),t("h2",{attrs:{id:"eval"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#eval"}},[a._v("#")]),a._v(" eval()")]),a._v(" "),t("h2",{attrs:{id:"不定宽高的情况下实现正方形-不定尺寸的图片自适应展示"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#不定宽高的情况下实现正方形-不定尺寸的图片自适应展示"}},[a._v("#")]),a._v(" 不定宽高的情况下实现正方形，不定尺寸的图片自适应展示")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("任意方向的 padding-top\n")])])]),t("h2",{attrs:{id:"弹性布局模型-flex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#弹性布局模型-flex"}},[a._v("#")]),a._v(" 弹性布局模型 Flex")]),a._v(" "),t("h2",{attrs:{id:"foreach-map中断循环-详细的用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#foreach-map中断循环-详细的用法"}},[a._v("#")]),a._v(" forEach Map中断循环(详细的用法)")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("forEach Map 不能跳出循环，Map返回的是一个数组，forEach只是对每个元素进行处理。 通过try…catch 可以\n")])])]),t("h2",{attrs:{id:"如何跟踪排除内存泄露"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何跟踪排除内存泄露"}},[a._v("#")]),a._v(" 如何跟踪排除内存泄露")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("[JS内存泄漏排查方法 - 云+社区 - 腾讯云](https://cloud.tencent.com/developer/article/1444558)\n")])])]),t("h2",{attrs:{id:"webpack单位件独立打包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack单位件独立打包"}},[a._v("#")]),a._v(" webpack单位件独立打包")]),a._v(" "),t("h2",{attrs:{id:"for-of-跟-for-in的差别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#for-of-跟-for-in的差别"}},[a._v("#")]),a._v(" for of 跟 for in的差别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("[javascript总for of和for in的区别？ - SegmentFault 思否](https://segmentfault.com/q/1010000006658882)\n")])])]),t("h2",{attrs:{id:"script-标签async-defer属性的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#script-标签async-defer属性的区别"}},[a._v("#")]),a._v(" "),t("code",[a._v("<script>")]),a._v("标签async defer属性的区别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("都是让js下载不阻止DOM渲染，但是defer会使js按顺序执行async是谁先下载好谁先执行\n")])])]),t("h2",{attrs:{id:"em-rem-px-区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#em-rem-px-区别"}},[a._v("#")]),a._v(" em rem px 区别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("px 相对于分辨率\nem 相对与 父元素的font-size\nrem 相对与 根元素的font-size\n")])])]),t("h2",{attrs:{id:"get跟post的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#get跟post的区别"}},[a._v("#")]),a._v(" get跟post的区别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("*误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。*\n参考答案\n实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点:\n")])])]),t("ul",[t("li",[a._v("HTTP 协议 未规定 GET 和POST的长度限制")]),a._v(" "),t("li",[a._v("GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度")]),a._v(" "),t("li",[a._v("不同的浏览器和WEB服务器，限制的最大长度不一样")]),a._v(" "),t("li",[a._v("要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte\n补充补充一个get和post在缓存方面的区别：")]),a._v(" "),t("li",[a._v("get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。")]),a._v(" "),t("li",[a._v("post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。")])]),a._v(" "),t("h2",{attrs:{id:"_1-2-3-map-parseint-输出什么-为什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-3-map-parseint-输出什么-为什么"}},[a._v("#")]),a._v(" ['1','2','3'].map(parseInt) 输出什么,为什么?")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("输出：[1, NaN, NaN]\n\n首先让我们回顾一下，map函数的第一个参数callback：var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])\n这个callback一共可以接收三个参数，其中第一个参数代表当前被处理的元素，而第二个参数代表该元素的索引。\n而parseInt则是用来解析字符串的，使字符串成为指定基数的整数。parseInt(string, radix)接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。了解这两个函数后，\n我们可以模拟一下运行情况\nparseInt('1', 0) //radix为0时，且string参数不以“0x”和“0”开头时，按照10为基数处理。这个时候返回1parseInt('2', 1) //基数为1（1进制）表示的数中，最大值小于2，所以无法解析，返回NaN\nparseInt('3', 2) //基数为2（2进制）表示的数中，最大值小于3，所以无法解析，返回NaNmap函数返回的是一个数组，所以最后结果为[1, NaN, NaN]")])])])])}),[],!1,null,null,null);s.default=n.exports}}]);