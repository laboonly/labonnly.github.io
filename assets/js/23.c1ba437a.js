(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{500:function(a,e,t){"use strict";t.r(e);var s=t(4),r=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h2",{attrs:{id:"webpack打包原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包原理"}},[a._v("#")]),a._v(" webpack打包原理")]),a._v(" "),t("p",[a._v("把所有依赖打包成bundle.js文件，通过代码分割单元片段并且按需加载")]),a._v(" "),t("h2",{attrs:{id:"webpack的优势"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack的优势"}},[a._v("#")]),a._v(" webpack的优势")]),a._v(" "),t("ol",[t("li",[a._v("webpack是以commonJS形式来书写脚本的，但对AMD/CMD的支持也很全面，方便旧项目进行代码迁移。")]),a._v(" "),t("li",[a._v("能被模块化的不仅仅是JS")]),a._v(" "),t("li",[a._v("开发便捷，能代替部分grunt/gulp 的工作，比如打包，压缩，混淆，图片转base64")]),a._v(" "),t("li",[a._v("拓展性强，插件丰富")])]),a._v(" "),t("h2",{attrs:{id:"什么事loader-plugin"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么事loader-plugin"}},[a._v("#")]),a._v(" 什么事loader，plugin")]),a._v(" "),t("p",[a._v("loader用于加载某些资源，因为本身只能打包符合common.js文件，比如图片，css就需要相应loader加载。\nplugin用于拓展webpack功能。")]),a._v(" "),t("h2",{attrs:{id:"什么是bundle-chunk-module"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是bundle-chunk-module"}},[a._v("#")]),a._v(" 什么是bundle，chunk，module")]),a._v(" "),t("p",[a._v("bundle: 是由webpack打包出来的文件\nchunk: 是指webpack进行模块依赖分析的时候，分割出来的代码块\nmodule: 是开发中的单个模块")]),a._v(" "),t("h2",{attrs:{id:"webpack跟gulp有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack跟gulp有什么区别"}},[a._v("#")]),a._v(" webpack跟gulp有什么区别")]),a._v(" "),t("p",[a._v("webpack:")]),a._v(" "),t("p",[a._v("webpack是个模块打包器，强调的是一个前端模块化解决方案，更侧重模块打包，我们可以把开发中的所有资源都看成是模块，\n通过loder和plugin对资源进行处理。")]),a._v(" "),t("p",[a._v("gulp:\ngulp是一个前端自动化构建工具，强调的是前端开发的工作流程，可以通过配置一系列的task，第一task处理的事情(如代码压缩，合并\n编译以及浏览器事实更新等)。然后定义这些执行顺序，来让gulp执行这些task，从而构建项目的整个开发流程。自动化构建工具并不能把所有模块\n都打包在一起，也不能构建不同模块之间的依赖关系。")]),a._v(" "),t("h2",{attrs:{id:"什么是模热更新-有什么优点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是模热更新-有什么优点"}},[a._v("#")]),a._v(" 什么是模热更新？有什么优点")]),a._v(" "),t("p",[a._v("模块热更新是webpack的一个功能，他可以使得代码修改后，不用刷新浏览器就可以更新。\n在应用过程中替换添加删除模块，无需重新加载整个页面，是高级版的自动刷新浏览器。")]),a._v(" "),t("p",[a._v("优点：\n只更新变更内容，节省开发时间，")]),a._v(" "),t("h2",{attrs:{id:"webpack-dev-serve-跟http服务什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-dev-serve-跟http服务什么区别"}},[a._v("#")]),a._v(" webpack-dev-serve 跟http服务什么区别")]),a._v(" "),t("p",[a._v("webpack-dev-serve 使用内存来储存webpack开发环境打包的文件，并且可以使用模块热更新，比传统http服务更有效")]),a._v(" "),t("h2",{attrs:{id:"什么事长缓存-在webpack中怎么做到长缓存优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么事长缓存-在webpack中怎么做到长缓存优化"}},[a._v("#")]),a._v(" 什么事长缓存？ 在webpack中怎么做到长缓存优化")]),a._v(" "),t("p",[a._v("浏览器在用户访问页面的时候，为了加快速度，会对用户访问的静态资源进行储存，但是每一次代码更新或者升级的时候，都需要浏览器去\n下载新的代码，最方便的方式就是引入新的文件名称")]),a._v(" "),t("p",[a._v("在webpack中，可以在output给出输出的文件定制chunkhash，并且分离经常更新的代码和框架代码，通过NameModulesPlugin\n或者HashedModulesPlugin使再次打包文件名不变。")]),a._v(" "),t("h2",{attrs:{id:"什么是tree-sharking-css可以tree-sharking吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是tree-sharking-css可以tree-sharking吗"}},[a._v("#")]),a._v(" 什么是tree-sharking? css可以tree-sharking吗")]),a._v(" "),t("p",[a._v("tree-sharking是指在打包中出去那些引入了，但是在代码中没有用到的死代码。在webpack中tree-sharking是通过uglifySPlugin来\n实现的，css需要Purify-css。")]),a._v(" "),t("h2",{attrs:{id:"如何自动生成webpack配置"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#如何自动生成webpack配置"}},[a._v("#")]),a._v(" 如何自动生成webpack配置")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("webpack-cli/vue-cli/etc...脚手架工具\n")])])]),t("h2",{attrs:{id:"webpack打包"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack打包"}},[a._v("#")]),a._v(" webpack打包")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("在生产环境中，webpack执行的时候build.js文件太大。每次请求都会消耗很大的流量，如果代码修改代码不会更新，浏览器记录了缓存。\n\n使用readfileSync读取packege.json文件中的版本号，把获取的version(版本号)加入到output出口文件中的build.js中。\n")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);