(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{496:function(t,e,r){"use strict";r.r(e);var s=r(4),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"js-对象看书笔记"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#js-对象看书笔记"}},[t._v("#")]),t._v(" js 对象看书笔记")]),t._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",[t._v("对象的基础属性")])]),t._v(" "),r("h2",{attrs:{id:"对象属性的特征"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#对象属性的特征"}},[t._v("#")]),t._v(" 对象属性的特征")]),t._v(" "),r("h3",{attrs:{id:"数据属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#数据属性"}},[t._v("#")]),t._v(" 数据属性")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("**Configurable** 可配置  默认为true 可配置 表示是否可以同过 delete删除属性从而重新定义属性，能否修改，能否修改为访问器属性。\n**Enumerable** 可枚举 默认为true 表示是否通过for-in 循环返回属性。\n**Writable** 可写 默认为true  可以修改属性的值\n**Value** 属性的数据值\n")])])]),r("h3",{attrs:{id:"访问器属性"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#访问器属性"}},[t._v("#")]),t._v(" 访问器属性")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("**Configurable** \n**Enumerable**\n**Get** 在读取属性时调用的函数\n**Set**  在写入属性时调用的函数\n\nObject.defineProperty(对象 ，属性值名称，描述符)  修改或者定义以上属性\nObject.defineProperties() 同时设置多个属性\n\nObject.getOwnPropertyDescriptor() 获取属性的描述符\n")])])]),r("h3",{attrs:{id:"任何函数只有通过new操作符来调用那他就可以作为构造函数-调用构造函数会经历以下四个阶段"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#任何函数只有通过new操作符来调用那他就可以作为构造函数-调用构造函数会经历以下四个阶段"}},[t._v("#")]),t._v(" 任何函数只有通过new操作符来调用那他就可以作为构造函数，调用构造函数会经历以下四个阶段:")]),t._v(" "),r("div",{staticClass:"language- line-numbers-mode"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("\t创建一个新的对象\n    将构造函数的作用域赋给新的对象（因此this指向这个新的对象）\n    执行构造函数中的代码（为这个对象添加属性）\n    返回新的对象\n")])]),t._v(" "),r("div",{staticClass:"line-numbers-wrapper"},[r("span",{staticClass:"line-number"},[t._v("1")]),r("br"),r("span",{staticClass:"line-number"},[t._v("2")]),r("br"),r("span",{staticClass:"line-number"},[t._v("3")]),r("br"),r("span",{staticClass:"line-number"},[t._v("4")]),r("br")])]),r("ul",[r("li",[r("p",[t._v("在全局作用域调用一个函数时this总是指向Global对象")])]),t._v(" "),r("li",[r("p",[t._v("以构造函数创建的实例上的同名函数是不相等的。")])]),t._v(" "),r("li",[r("p",[t._v("创建每个函数都有一个portotype(原型属性)，这个属性是一个指针，指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性跟方法")])]),t._v(" "),r("li",[r("p",[t._v("原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype所在函数的指针  Person.prototype.constructor 指向 Person")])]),t._v(" "),r("li",[r("p",[t._v("创建一个实例后，实例会获得一个指向构造函数的原型对象的指针_proto_\n“"),r("em",[t._v("proto")]),t._v("”  没办法访问  但是可以通过isPrototypeOf() 来确定对象之间是否存在这种关系 Person.prototype.isPrototypeOf(Person1) true\nObject.getPrototypeOf() 方法可以返回“"),r("em",[t._v("proto")]),t._v("”的值")])]),t._v(" "),r("li",[r("p",[t._v("当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，\n使用hasOwnproperty()方法可以检测一个属性是否存在于实例中\nin  操作符会在通过对象能够访问的给定属性时返回true，无论在实例还是原型中\nfor-in  是返回所有对象可以访问到的可以枚举的属性 ，默认所有开发人员定义的属性都是可以枚举的\nObject.keys() 返回对像上所有可枚举的实例属性（一个字符串）\nObject.getOwnPropertyNames() 枚举所有属性，不管是否可枚举")])]),t._v(" "),r("li",[r("p",[t._v("原型的动态性对原型对象的所有修改都能够立即从实例上反映出来，因为实例与原型之间的链接只不过是一个指针，而非一个副本。")])]),t._v(" "),r("li",[r("p",[t._v("原型对象的问题 引用类型的属性X会被实例共享，然后实例A修改了共享的引用类型X之后所有实例的X都会被修改（正是这个原因导致继承不单独使用原型模式）")])]),t._v(" "),r("li",[r("p",[t._v("组合使用构造函数与原型模式\n构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性  这是一种最广泛认同度最高的创建自定义类型的方法")])]),t._v(" "),r("li",[r("p",[t._v("动态原型模式\n通过检查某个应该存在的方法是否有效，来决定是否初始化原型")])]),t._v(" "),r("li",[r("p",[t._v("寄生构造函数模式")])]),t._v(" "),r("li",[r("p",[t._v("原型链\n让原型对象等于另一个类型的实例，层层递进构成原型链。")])]),t._v(" "),r("li",[r("p",[t._v("instanceof"),r("br"),t._v("\ninstanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置")])]),t._v(" "),r("li",[r("p",[t._v("isPrototypeOf\nisPrototypeOf方法用于测试一个对象是否存在于另一个对象的原型链上。")])]),t._v(" "),r("li",[r("p",[t._v("包含引用类型的值得原型属性会被所有实例共享")])]),t._v(" "),r("li",[r("p",[t._v("原型链的问题")]),t._v(" "),r("ol",[r("li",[t._v("在通过原型来实现继承时，原型实际上会变成另外一个类型的实例。于是，原先实例属性也就变成了现在的原型属性")]),t._v(" "),r("li",[t._v("不能传递参数")])])]),t._v(" "),r("li",[r("p",[t._v("借用构造属性\n“3. 执行构造函数中的代码（为这个对象添加属性）”")])]),t._v(" "),r("li",[r("p",[t._v("组合继承\n使用原型链实现对原型属性方法的继承，而通过“借用构造函数”来实现对实例属性的继承")])]),t._v(" "),r("li",[r("p",[t._v("原型式继承\n基于已有的对象(一般指非函数对象)创建新的对象，对对象的一次浅复制，")])]),t._v(" "),r("li",[r("p",[t._v("寄生式继承\n基于原型式继承的增强 比如增加方法")])]),t._v(" "),r("li",[r("p",[t._v("寄生组合式继承\n利用原生式继承替换掉组合继承中的 原型继承中的直接调用超类型构造函数")])])])])}),[],!1,null,null,null);e.default=n.exports}}]);