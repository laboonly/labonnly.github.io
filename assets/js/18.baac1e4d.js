(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{497:function(a,e,t){"use strict";t.r(e);var s=t(4),r=Object(s.a)({},(function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h1",{attrs:{id:"vue面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue面试题"}},[a._v("#")]),a._v(" vue面试题")]),a._v(" "),t("h2",{attrs:{id:"v-show-v-if-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-show-v-if-的区别"}},[a._v("#")]),a._v(" v-show v-if 的区别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("不同点：v-if显示隐藏是将dom元素整个添加或删除，而v-show隐藏则是为该元素添加css--display:none，dom元素还在。\n")])])]),t("h2",{attrs:{id:"vue生命周期"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue生命周期"}},[a._v("#")]),a._v(" vue生命周期")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("总共分为 8 个阶段创建前_后，载入前_后，更新前_后，销毁前_后。\n\n1. 创建前/后： 在 beforeCreate 阶段，vue 实例的挂载元素 el 还没有。\n\n2. 载入前/后：在 beforeMount 阶段，vue 实例的$el 和 data 都初始化了，但还是挂载之前为虚拟的 dom 节点，data.message 还未替换。在 mounted 阶段，vue 实例挂载完成，data.message 成功渲染。\n\n3. 更新前/后：当 data 变化时，会触发 beforeUpdate 和 updated 方法。\n\n4. 销毁前/后：在执行 destroy 方法后，对 data 的改变不会再触发周期函数，说明此时 vue 实例已经解除了事件监听以及和 dom 的绑定，但是 dom 结构依然存在\n")])])]),t("h2",{attrs:{id:"vue里面的虚拟dom是怎么回事"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue里面的虚拟dom是怎么回事"}},[a._v("#")]),a._v(" vue里面的虚拟dom是怎么回事？")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("在js模拟dom节点内容，进行dom操作。减少操作dom的开销。\n")])])]),t("h2",{attrs:{id:"vue双向绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue双向绑定"}},[a._v("#")]),a._v(" vue双向绑定")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("vue通过发布者订阅跟数据劫持实现(Object.defineProperty).使用defineProperty重写每个属性的 get/set\n")])])]),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/canfoo/p/6891868.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("vue的双向绑定原理及实现 - canfoo#! - 博客园"),t("OutboundLink")],1)]),a._v(" "),t("h2",{attrs:{id:"vue-nexttick"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-nexttick"}},[a._v("#")]),a._v(" vue.nextTick")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("在下次更新结束后执行延迟回调，在修改数据后立即使用这个方法，获取更新之后的dom\n")])])]),t("h2",{attrs:{id:"组件之间的传值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组件之间的传值"}},[a._v("#")]),a._v(" 组件之间的传值")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("父组件传给子组件，props\n子组件传给父组件，$emit方法传递参数\n兄弟组件之间 vuex\n")])])]),t("h2",{attrs:{id:"vue-router-beforeeach"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-router-beforeeach"}},[a._v("#")]),a._v(" vue-router beforeEach")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("子路由跳转间进行控制\n")])])]),t("h2",{attrs:{id:"vuex"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex"}},[a._v("#")]),a._v(" vuex")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("state: 储存数据状态\nmutations：定义修改state里面的数据\ngetters：获取或者过滤一些数据\nactions: actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法\nmodules: 项目特别复杂的时候，可以让每一个模块拥有自己的state、mutation、action、getters,使得结构非常清晰，方便管理。\n")])])]),t("h2",{attrs:{id:"自定义指令"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#自定义指令"}},[a._v("#")]),a._v(" 自定义指令")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("directives\n")])])]),t("h2",{attrs:{id:"对keep-alive的了解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对keep-alive的了解"}},[a._v("#")]),a._v(" 对keep-alive的了解")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。\n")])])]),t("h2",{attrs:{id:"vue为什么只有一个根元素-template也必须有且只有一个div"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue为什么只有一个根元素-template也必须有且只有一个div"}},[a._v("#")]),a._v(" vue为什么只有一个根元素, template也必须有且只有一个div")]),a._v(" "),t("h2",{attrs:{id:"v-for-跟-v-if-那个优先级高"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#v-for-跟-v-if-那个优先级高"}},[a._v("#")]),a._v(" v-for 跟 v-if 那个优先级高")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("v-for\n")])])]),t("h2",{attrs:{id:"data-为什么必须是函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#data-为什么必须是函数"}},[a._v("#")]),a._v(" data 为什么必须是函数")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("每一个vue组件都是一个vue实例，通过new Vue()实例化，引用同一个对象，如果data直接是一个对象的话，那么一旦修改其中一个组件的数据，其他组件相同数据就会被改变。\n而data是函数的话，每个vue组件的data都因为函数有了自己的作用域，互不干扰。\n")])])]),t("h2",{attrs:{id:"你怎么理解vue中的diff算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#你怎么理解vue中的diff算法"}},[a._v("#")]),a._v(" 你怎么理解vue中的diff算法？")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/4f67c3f216a0",target:"_blank",rel:"noopener noreferrer"}},[a._v("Vue中的diff算法 - 简书"),t("OutboundLink")],1)]),a._v(" "),t("h2",{attrs:{id:"vue当中的性能优化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue当中的性能优化"}},[a._v("#")]),a._v(" vue当中的性能优化")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("●路由懒加载\n●keep-alive缓存页面\n●使用v-show复用DOM\n●v-for 遍历避免同时使用 v-if\n●长列表性能优化\n●事件的销毁\n●图片懒加载\n●第三方插件按需引入\n●无状态的组件标记为函数式组件\n●子组件分割\n●变量本地化\n")])])]),t("h2",{attrs:{id:"vuex的多标签页时状态变化串页面解决思路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex的多标签页时状态变化串页面解决思路"}},[a._v("#")]),a._v(" vuex的多标签页时状态变化串页面解决思路")]),a._v(" "),t("h2",{attrs:{id:"watch-的immediate与created执行顺序比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watch-的immediate与created执行顺序比较"}},[a._v("#")]),a._v(" watch 的immediate与created执行顺序比较")]),a._v(" "),t("p",[a._v("watch 加了 immediate: true, 就是watch先执行，否则就是created 先执行")]),a._v(" "),t("h2",{attrs:{id:"watch-跟-computed-有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#watch-跟-computed-有什么区别"}},[a._v("#")]),a._v(" watch 跟 computed 有什么区别")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("computed 　　　　\n　　　　当一个属性受多个属性影响的时候就需要用到computed\n　　　　最典型的例子： 购物车商品结算的时候\nwatch\n　　　　当一条数据影响多条数据的时候就需要用watch\n　　　　搜索数据\n")])])]),t("h2",{attrs:{id:"vue-的provide-和-inject是如何使用的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-的provide-和-inject是如何使用的"}},[a._v("#")]),a._v(" vue 的provide 和 inject是如何使用的")]),a._v(" "),t("p",[t("a",{attrs:{href:"https://www.jianshu.com/p/d34a7df4cd6a",target:"_blank",rel:"noopener noreferrer"}},[a._v("浅谈vue中provide和inject 用法 - 简书"),t("OutboundLink")],1)]),a._v(" "),t("h2",{attrs:{id:"父组件执行到那个周期子组件开始执行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#父组件执行到那个周期子组件开始执行"}},[a._v("#")]),a._v(" 父组件执行到那个周期子组件开始执行")]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[a._v("渲染过程：父组件挂载完成一定是等子组件都挂载完成后，才算是父组件挂载完，所以父组件的mounted在子组件mouted之后。父beforeCreate -> 父created -> 父beforeMount -> 子beforeCreate -> 子created -> 子beforeMount -> 子mounted -> 父mounted\n")])])]),t("h2",{attrs:{id:"vuex-mutation-里面为什么不能使用异步请求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vuex-mutation-里面为什么不能使用异步请求"}},[a._v("#")]),a._v(" vuex mutation 里面为什么不能使用异步请求")])])}),[],!1,null,null,null);e.default=r.exports}}]);