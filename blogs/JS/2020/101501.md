---
title: 高级程序3 JS对象看书笔记
date: 2020-10-15
tags:
 - js
categories:
 - JS
---

# js 对象看书笔记
:::tip
对象的基础属性
:::


## 对象属性的特征
### 数据属性
	**Configurable** 可配置  默认为true 可配置 表示是否可以同过 delete删除属性从而重新定义属性，能否修改，能否修改为访问器属性。
	**Enumerable** 可枚举 默认为true 表示是否通过for-in 循环返回属性。
	**Writable** 可写 默认为true  可以修改属性的值
	**Value** 属性的数据值
	
### 访问器属性
	**Configurable** 
	**Enumerable**
	**Get** 在读取属性时调用的函数
	**Set**  在写入属性时调用的函数
	
	Object.defineProperty(对象 ，属性值名称，描述符)  修改或者定义以上属性
	Object.defineProperties() 同时设置多个属性
	
	Object.getOwnPropertyDescriptor() 获取属性的描述符
### 任何函数只有通过new操作符来调用那他就可以作为构造函数，调用构造函数会经历以下四个阶段:
    1. 创建一个新的对象
    2. 将构造函数的作用域赋给新的对象（因此this指向这个新的对象）
    3. 执行构造函数中的代码（为这个对象添加属性）
    4. 返回新的对象
     
* 在全局作用域调用一个函数时this总是指向Global对象

*  以构造函数创建的实例上的同名函数是不相等的。

* 创建每个函数都有一个portotype(原型属性)，这个属性是一个指针，指向一个对象，这个对象包含可以由特定类型的所有实例共享的属性跟方法

* 原型对象都会自动获得一个constructor（构造函数）属性，这个属性是一个指向prototype所在函数的指针  Person.prototype.constructor 指向 Person

* 创建一个实例后，实例会获得一个指向构造函数的原型对象的指针_proto_ 
“_proto_”  没办法访问  但是可以通过isPrototypeOf() 来确定对象之间是否存在这种关系 Person.prototype.isPrototypeOf(Person1) true
Object.getPrototypeOf() 方法可以返回“_proto_”的值

* 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性，
	使用hasOwnproperty()方法可以检测一个属性是否存在于实例中
	in  操作符会在通过对象能够访问的给定属性时返回true，无论在实例还是原型中
	for-in  是返回所有对象可以访问到的可以枚举的属性 ，默认所有开发人员定义的属性都是可以枚举的
	Object.keys() 返回对像上所有可枚举的实例属性（一个字符串）
	Object.getOwnPropertyNames() 枚举所有属性，不管是否可枚举

* 原型的动态性对原型对象的所有修改都能够立即从实例上反映出来，因为实例与原型之间的链接只不过是一个指针，而非一个副本。

* 原型对象的问题 引用类型的属性X会被实例共享，然后实例A修改了共享的引用类型X之后所有实例的X都会被修改（正是这个原因导致继承不单独使用原型模式）

* 组合使用构造函数与原型模式 
	构造函数用于定义实例属性，而原型模式用于定义方法和共享的属性  这是一种最广泛认同度最高的创建自定义类型的方法 

* 动态原型模式 
 	通过检查某个应该存在的方法是否有效，来决定是否初始化原型

*  寄生构造函数模式
	
* 原型链
 	让原型对象等于另一个类型的实例，层层递进构成原型链。

* instanceof  
	 instanceof运算符用于测试构造函数的prototype属性是否出现在对象的原型链中的任何位置

* isPrototypeOf
	isPrototypeOf方法用于测试一个对象是否存在于另一个对象的原型链上。

* 包含引用类型的值得原型属性会被所有实例共享

* 原型链的问题
	1. 在通过原型来实现继承时，原型实际上会变成另外一个类型的实例。于是，原先实例属性也就变成了现在的原型属性
	2. 不能传递参数

* 借用构造属性
	  “3. 执行构造函数中的代码（为这个对象添加属性）”  

* 组合继承
	使用原型链实现对原型属性方法的继承，而通过“借用构造函数”来实现对实例属性的继承

* 原型式继承
	基于已有的对象(一般指非函数对象)创建新的对象，对对象的一次浅复制，

* 寄生式继承
	基于原型式继承的增强 比如增加方法

* 寄生组合式继承
	利用原生式继承替换掉组合继承中的 原型继承中的直接调用超类型构造函数
